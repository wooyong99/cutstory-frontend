# PRD.md — 미용실 예약 웹 애플리케이션 (Frontend)

## 1. 문서 개요

### 1.1 목적

미용실 예약 웹 애플리케이션의 프론트엔드 요구사항(기능/UX/기술 스택)을 정의하여, 기획·디자인·개발·테스트 단계에서 구현 기준을 일관되게 유지한다.

### 1.2 범위

- **포함**: 회원가입(자체 회원가입), 메인(헤어 스타일 선택), 상세(달력/시간 선택 예약), 예약 불가 시간 표시, 반응형 UI, 로딩/빈상태/에러 상태 정의, 프론트엔드 기술 스택 결정
- **제외**: 결제, 관리자 페이지, 미용사 스케줄 관리(추후 확장)

---

## 2. 제품 개요

### 2.1 문제/기회

- 사용자는 전화/DM 대신 웹에서 빠르게 예약하고 싶다.
- 예약 가능 시간/불가능 시간을 명확히 보고 싶다.
- 모바일에서도 사용성이 좋아야 한다(반응형 필수).

### 2.2 목표

- 회원가입 → 스타일 선택 → 날짜/시간 선택 → 예약 완료까지의 흐름을 **최소 클릭/최소 혼란**으로 제공한다.
- 예약 불가 시간은 사용자가 즉시 인지할 수 있도록 **시각적으로 명확하게** 표시한다.
- 로딩/빈상태/오류를 “불안하지 않게” 표현한다.

### 2.3 핵심 지표 (예시)

- 회원가입 완료율
- 예약 완료율
- 상세 페이지 이탈률(달력/시간 선택 단계)
- 예약 실패율(동시성/중복 예약)

---

## 3. 사용자 & 시나리오

### 3.1 사용자

- 웹 방문자(비회원) → 회원가입 후 예약 가능
- 회원(로그인 상태) → 스타일 선택 및 예약 가능

### 3.2 핵심 사용자 스토리

1. 비회원은 예약을 위해 회원가입을 반드시 해야 한다.
2. 회원은 메인에서 헤어 스타일을 선택하고 상세로 이동한다.
3. 상세에서 날짜(요일) 선택 후 1시간 단위로 시간을 선택하여 예약한다.
4. 다른 사용자가 이미 예약한 시간은 선택 불가이며 **불투명하게 표시**되어야 한다.

---

## 4. 정보 구조 & 화면

### 4.1 라우팅(초안)

- `/signup` 회원가입
- `/login` 로그인 (필요 시)
- `/` 메인(스타일 목록)
- `/styles/:styleId` 스타일 상세(달력 + 시간 슬롯 + 예약)

> 정책: **예약 기능은 로그인(회원)만 가능**. 비회원이 예약 관련 동작 시 `/signup` 또는 `/login` 유도.

### 4.2 화면 요약

- 회원가입 페이지: 이름/나이/이메일/휴대폰 번호 입력 + 가입
- 메인 페이지: 헤어 스타일 카드/리스트 → 상세 이동
- 상세 페이지: 달력(요일 선택) + 시간 슬롯(1시간 단위) + 예약 버튼
  - 예약 불가 슬롯: 비활성 + 불투명(예: opacity)

---

## 5. 기능 요구사항 (Functional Requirements)

## 5.1 회원가입

### 5.1.1 입력 필드

- 이름 (필수)
- 나이 (필수, 숫자)
- 이메일 (필수, 이메일 형식)
- 휴대폰 번호 (필수, 형식: 예 `010-1234-5678` 또는 숫자만 입력 허용 후 자동 포맷)

### 5.1.2 검증(Validation) 정책

- 검증 시점: **blur 시 1차**, submit 시 최종
- 오류 메시지:
  - 필드 바로 아래 인접 노출
  - 기술적인 메시지 금지(예: “500” 금지)
  - 사용자가 다음 행동을 알 수 있는 문장(예: “이메일 형식이 올바르지 않습니다.”)

### 5.1.3 가입 완료 후

- 성공 토스트/안내 후 메인(`/`) 이동 (또는 로그인 처리 정책에 따라 자동 로그인)

---

## 5.2 메인(스타일 선택)

### 5.2.1 스타일 리스트

- 스타일 카드: 이미지(선택), 스타일명, 소요시간(옵션), 가격(옵션)
- 클릭 시 스타일 상세(`/styles/:styleId`)로 이동

### 5.2.2 빈 상태(Empty)

- 스타일이 없을 경우
  - “현재 예약 가능한 스타일이 없습니다.”
  - “잠시 후 다시 시도해주세요.” + 새로고침/재시도 버튼

---

## 5.3 스타일 상세(예약)

### 5.3.1 달력(요일 선택)

- 월/주 전환 여부는 UI 정책에 따라 결정(초안: 월 캘린더)
- 날짜 선택 시 해당 날짜의 시간 슬롯 데이터를 조회/갱신

### 5.3.2 시간 슬롯(1시간 단위)

- 표시 예: `10:00`, `11:00` ... `19:00`
- 슬롯 상태:
  - **available**: 선택 가능
  - **reserved**: 선택 불가 + 불투명 표시(opacity) + 커서/hover 비활성
  - **selected**: 선택됨(강조)
  - **loading**: 슬롯 영역만 로딩 스켈레톤/placeholder

### 5.3.3 예약 불가 시간 표시(필수)

- 다른 사용자가 예약한 시간은:
  - 시각적 불투명 처리(opacity)
  - 클릭 불가(disabled)
  - 접근성: `aria-disabled="true"` 적용

### 5.3.4 예약 액션

- “예약하기” 버튼 클릭 시 예약 요청
- 중복 클릭 방지:
  - 요청 중 버튼 disabled
  - 버튼 내부 로딩 인디케이터(스피너) 또는 텍스트 변경(예: “예약 중…”)

### 5.3.5 동시성(UX 관점)

- 사용자가 선택한 슬롯이 요청 시점에 이미 예약된 경우:
  - “방금 다른 사용자가 예약했어요. 다른 시간을 선택해주세요.”
  - 슬롯 데이터 리프레시(해당 날짜 재조회)

### 5.3.6 빈 상태(시간 없음)

- 해당 날짜에 예약 가능한 시간이 전혀 없을 경우:
  - “이 날짜에는 예약 가능한 시간이 없습니다.”
  - “다른 날짜를 선택해보세요.”

---

## 6. UI/UX 상세 요구사항 (구현 가능한 기준)

### 6.1 클릭 가능 요소 가시성(필수)

- 클릭 가능한 요소는 아래 중 하나로 반드시 표현:
  - 버튼 스타일(배경/테두리/그림자 등)
  - hover/active 상태(데스크탑)
  - 커서(pointer)
  - 모바일: 터치 시 pressed 상태(시각 피드백)
- disabled 상태는 명확해야 함:
  - 대비되는 색상/opacity
  - 커서 변경(가능 시)
  - hover 효과 제거

### 6.2 로딩(필수)

- 모든 비동기 요청은 로딩 상태를 가진다.
- 전체 화면 로딩(초기 진입/핵심 데이터 없음):
  - 스피너 또는 스켈레톤
- 부분 로딩(달력 날짜 변경으로 슬롯만 갱신 등):
  - 해당 영역만 스켈레톤/placeholder
  - 기존 데이터가 있으면 유지한 채 로딩 표시(깜빡임 최소화)

### 6.3 빈 상태(필수)

- Empty는 오류처럼 보이면 안 된다.
- 반드시 포함:
  - 현재 상태 설명(왜 비어있는지/지금 어떤 상태인지)
  - 다음 행동(재시도/날짜 변경/검색 조건 변경 등)

### 6.4 에러(권장)

- 사용자 메시지 중심
- 재시도 가능 시 CTA 제공(“다시 시도”)
- 네트워크 오류/서버 오류/검증 오류 분리 가능하면 분리

### 6.5 반응형(필수)

- 모바일 우선 설계 권장
- 최소 기준:
  - Mobile ≤ 767px
  - Tablet 768~1199px
  - Desktop ≥ 1200px
- 시간 슬롯은 모바일에서 가독성 확보:
  - 2열/3열 그리드(화면 폭에 따라)
  - 터치 영역 최소 44px 권장

### 6.6 접근성(권장)

- 버튼/입력 필드 aria 속성 적용
- 예약 불가 슬롯은 `aria-disabled` 등으로 상태 전달

---

## 7. 비기능 요구사항 (Non-functional)

### 7.1 성능

- 라우트 단위 코드 스플리팅(필요 시)
- 상세 페이지에서 캘린더/슬롯 렌더링 성능 고려(불필요한 리렌더 최소화)

### 7.2 유지보수성

- UI 컴포넌트와 비즈니스 로직 분리(예: hooks/service 분리)
- 상태/서버 데이터 흐름이 추적 가능해야 함
- 공통 로딩/에러/빈 상태 컴포넌트화 권장

---

## 8. 기술 스택 요구사항 (Frontend)

### 8.1 고정 기술 스택

- React 19
- TypeScript
- Vite
- (권장) React Router
- (권장) ESLint/Prettier + CI에서 체크

### 8.2 상태관리 라이브러리 선택 (장단점/트레이드오프)

> 전제: 이 서비스는 “예약 가능 시간” 같은 **서버 상태**가 핵심이며,  
> “회원 정보/선택 상태” 같은 **클라이언트 상태**도 존재한다.  
> 따라서 **서버 상태 관리 도구 + 클라이언트 상태 관리 도구**를 분리해 생각하는 것이 실무적으로 가장 안전하다.

---

### 옵션 A) React Context + useReducer (라이브러리 미사용)

**장점**

- 추가 의존성 없음(가벼움)
- 작은 앱에서 빠르게 시작 가능

**단점**

- Context 업데이트로 인한 리렌더 범위가 커질 수 있음(성능 이슈 발생 쉬움)
- 비동기/캐싱/리트라이 같은 서버 상태 관리 기능은 직접 구현 필요
- 규모 커질수록 패턴/컨벤션 없으면 유지보수 난이도 상승

**적합**

- 상태가 매우 단순하고, 서버 캐싱 전략이 거의 필요 없을 때

**트레이드오프**

- “처음은 빠르지만, 커지면 정리 비용이 큼”

---

### 옵션 B) Zustand (클라이언트 상태)

**장점**

- 매우 간단한 API(학습/도입 비용 낮음)
- 성능 좋고(선택적 구독), 보일러플레이트 적음
- “선택한 날짜/시간, 임시 폼 상태” 같은 UI 상태 관리에 적합

**단점**

- 팀 컨벤션 없으면 store가 커지며 비즈니스 로직이 섞일 위험
- 서버 상태(캐싱/리트라이)는 별도 도구가 필요

**적합**

- 예약 플로우에서 “선택 상태/모달/필터” 등의 클라이언트 상태가 분명히 있고, 간결함이 중요할 때

**트레이드오프**

- “단순함 ↔ 아키텍처 강제력 부족(규칙을 팀이 세워야 함)”

---

### 옵션 C) Redux Toolkit (RTK) (클라이언트 상태)

**장점**

- 실무에서 보편적(협업/채용/레퍼런스 풍부)
- 구조/패턴이 강해서 대규모에서 예측 가능
- DevTools/미들웨어 등 생태계 강력

**단점**

- 작은 앱에는 보일러플레이트가 상대적으로 큼
- 러닝커브/설계 비용이 듦
- UI 임시 상태까지 넣으면 과해질 수 있음

**적합**

- 향후 기능이 크게 확장되고 팀이 커질 가능성이 높을 때

**트레이드오프**

- “규모가 커질수록 이득 ↔ 초기 개발 속도/간결함 감소”

---

### 옵션 D) Jotai (클라이언트 상태)

**장점**

- atom 단위로 상태를 쪼개 관리 → UI 상태에 깔끔
- 필요한 것만 구독(성능 유리)
- 복잡한 전역 store 없이도 확장 가능

**단점**

- 팀 경험/레퍼런스가 Zustand/Redux 대비 적을 수 있음
- atom 설계가 난잡해지면 추적이 어려움(컨벤션 필요)

**적합**

- “화면 단위로 작은 상태가 많고” 조립형 UI가 많은 경우

**트레이드오프**

- “유연함 ↔ 팀 합의 없는 확장 시 복잡도 증가”

---

### 서버 상태(강력 권장) — TanStack Query(React Query)

**왜 별도로 고려?**

- 예약 가능 시간/예약 목록은 서버 데이터이며,
  - 캐싱
  - 리페치
  - 로딩/에러 상태 표준화
  - 리트라이/중복 요청 방지
  - 낙관적 업데이트(필요 시)
    같은 기능이 중요하다.

**장점**

- 서버 상태를 “데이터 패칭 + 캐싱” 관점에서 표준화
- 로딩/에러 처리 패턴이 명확해져 UI 품질 상승
- 날짜 변경 시 “부분 로딩” 구현이 쉬움

**단점**

- 개념(쿼리 키/캐시/무효화)을 이해해야 함

---

## 8.3 추천 조합 (초안 결론)

### 추천 1) TanStack Query + Zustand

- **서버 상태**: TanStack Query로 표준화 (예약 가능 시간/스타일 리스트)
- **클라이언트 상태**: Zustand로 UI/선택 상태 관리 (선택한 날짜/시간, 폼 임시 상태)

**추천 이유**

- 예약 앱은 서버 상태가 핵심 → React Query가 UX 품질(로딩/부분 로딩/재시도)을 크게 올림
- Zustand는 간결하면서도 선택 상태를 명확히 분리하기 좋음

### 추천 2) TanStack Query + Redux Toolkit

- 팀이 크거나, 향후 관리자/정산/복잡한 정책이 크게 붙는다면 고려
- 대신 초기 개발 비용은 증가

---

## 9. QA / DoD (Definition of Done)

### 9.1 기능 DoD

- [ ] 회원가입 필수 필드/검증 동작
- [ ] 스타일 선택 → 상세 이동
- [ ] 날짜 선택 → 시간 슬롯 갱신
- [ ] 예약된 시간은 불투명 + 선택 불가
- [ ] 예약 요청 중 중복 클릭 방지
- [ ] 동시성 충돌 시 사용자 안내 + 데이터 갱신

### 9.2 UX DoD

- [ ] 클릭 가능한 요소는 시각적으로 명확(hover/pressed/커서)
- [ ] 전체 로딩: 스피너/스켈레톤 표시
- [ ] 부분 로딩: 해당 영역만 로딩 표시(기존 데이터 flicker 최소화)
- [ ] 빈 상태 UI가 오류처럼 보이지 않음(안내 + 다음 행동)
- [ ] 반응형에서 레이아웃 깨짐 없음(모바일/태블릿/데스크탑)

---

## 10. 오픈 이슈 / 결정 필요 사항

- 로그인 페이지가 필요한가? (회원가입 후 자동 로그인 정책 포함)
- 시간 슬롯 범위(오픈/마감 시간), 휴무일/예약 불가 요일 정책
- 예약 성공 후 UX (완료 페이지 vs 토스트 + 상세 유지)
- 캘린더 UI: 월/주 전환 필요 여부
